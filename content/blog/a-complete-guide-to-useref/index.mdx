---
title: A Complete Guide to useRef
date: "2020-11-03T22:12:03.284Z"
description: "Hello World"
---
import OutsideVariable from './Examples/OutsideVariable'
import OutsideVariableMultiple from './Examples/OutsideVariable/multiple'
import OutsideVariableTest from './Examples/OutsideVariable/test'
import RefButton from "./Examples/Buttons/RefButton"
import AttachingToDomExample from './Examples/AttachingToDomExample'
import Chat from '../Chat'

## What's useRef
`useRef` allows you to keep a mutable value within a component, similar to `useState` or instance variables on a class, without triggering re-renders.

For example, this component stores the number of clicks

```jsx
function RefButton () {
  const clicks = useRef(0)

  return (
    <button onClick={() => (clicks.current += 1)}>
      Clicks: {clicks.current}
    </button>
  )
}
```

This is how this component would look:

<RefButton />

As you can see it doesn't do anything. Let's add a bit more of magic so you can
see what happens. Below is the exact same button with a button that
triggers a re-render:

<OutsideVariableMultiple refs={1} displayType={false} />

### Why not just use a variable?
You might wonder why not just use a simple variable as the example below:

<OutsideVariableMultiple variable={1} />

The code works. However, the problem arises when you have multiple instances of the same component like the example below. Try clicking just one of the buttons below and then click on re-render to see the result.

<OutsideVariableMultiple variable={2} />

As you were able to see, the clicks are not isolated. On the otherside, useRef values are completely isolated between components.
In fact, you can notice that the clicks count from the previous example is updated if you click re-render!

<OutsideVariableMultiple refs={3} />

## Difference withÂ useState
`useState` triggers a re-render everytime it's updated and `useRef` doesn't. In the following example I added two buttons: one updates its count with `useRef` and the other one with `useState`. You'll notice that clicking on the button with `useRef` doesn't trigger a re-render and thus, the view isn't updated. It will be only noticeable when you click the button that uses `useState`.

<OutsideVariableMultiple refs={1} state={1} />

## Refs as a way to access underline DOM elements

To perform imperative actions on DOM nodes, React provides a way to get a
reference to them via refs. All you have to do is to assign a `ref` property to
a node with a ref object like this:

```jsx
function CustomInput() {
  const inputRef = useRef()

  return <input ref={inputRef} />
}
```

The way to get a DOM reference using refs works (informally ðŸ˜…) is as follows:

<Chat
  messages={{
'Today': [
    { message:  'Hey React', side: 'right', time:'12:00' },
    { name: 'React', message: "Hey, what's up?", side: 'left', time: '12:00'},
    { message: "Could you give me a reference to this dom node?", side: 'right', time: '12:00' },
    { name:'React', message: "Sure, I assigned it to the 'current' property of your ref.", side: 'left', time:'12:00' },
    { message: "Cool, thanks!", side: 'right', time:'12:00' },
  ]}
}
 />

On the first render inputRef's value will be `{ current: null }` and in the
following renders will have its `current` property assigned to the specified DOM
node:

```jsx
// First render: { current: undefined }
// Second render: { current: <input /> }
// Third render: { current: <input /> }
/// ...and so on
console.log(inputRef)
```

However, if you only reference `inputRef` inside `useEffect` then it'll always
reference the DOM node so you don't need to worry about it being undefined.

Let's update our example to get an idea of how this works:

```jsx
function AttachingToDomExample() {
  const inputRef = useRef()

  console.log("Render inputRef value:", inputRef)

  useEffect(() => console.log("useEffect inputRef value:", inputRef))

  return <input ref={inputRef} />
}
```

Here's the console output when rendering this component:

| Render | Location | Value                       |
|:------:|:-------|:-----------------------------:|
| 1      |  Render    | { current: undefined }  |
|        |  useEffect | { current: <input /\> } |
| 2      |  Render    | { current: <input /\> } |
|        |  useEffect | { current: <input /\> } |
| 3      |  Render    | { current: <input /\> } |
|        |  useEffect | { current: <input /\> } |

As you can see, if you access the `inputRef` inside `useEffect` then you don't
need to worry about it being `undefined` because React will assign it
automatically for you.

## Difference with a variable
- Refs to access DOM nodes
- Why not just use a variable?
- Why not use `useState`?
- Use cases for refs: usePrevious
- Lazy Initialization
- Conceptually, you can think of refs as similar to instance variables in a class. Unless you're doing lazy initialization, avoid setting refs during renderingâ€Š-â€Šthis can lead to surprising behavior. Instead, typically you want to modify refs in event handlers and effects.
- Callback refs

This is my first post on my new fake blog! How exciting!

I'm sure I'll write a lot more interesting things in the future.

Oh, and here's a great quote from this Wikipedia on
[salted duck eggs](https://en.wikipedia.org/wiki/Salted_duck_egg).

> A salted duck egg is a Chinese preserved food product made by soaking duck
> eggs in brine, or packing each egg in damp, salted charcoal. In Asian
> supermarkets, these eggs are sometimes sold covered in a thick layer of salted
> charcoal paste. The eggs may also be sold with the salted paste removed,
> wrapped in plastic, and vacuum packed. From the salt curing process, the
> salted duck eggs have a briny aroma, a gelatin-like egg white and a
> firm-textured, round yolk that is bright orange-red in color.

![Chinese Salty Egg](./salty_egg.jpg)

You can also write code blocks here!

```js
const saltyDuckEgg = "chinese preserved food product"
```

| Number | Title                                    | Year |
| :----- | :--------------------------------------- | ---: |
| 1      | Harry Potter and the Philosopherâ€™s Stone | 2001 |
| 2      | Harry Potter and the Chamber of Secrets  | 2002 |
| 3      | Harry Potter and the Prisoner of Azkaban | 2004 |
