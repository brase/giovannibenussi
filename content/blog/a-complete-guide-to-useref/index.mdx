---
title: A Complete Guide to useRef
date: "2020-11-03T22:12:03.284Z"
description: "Hello World"
---
import OutsideVariable from './Examples/OutsideVariable'
import OutsideVariableMultiple from './Examples/OutsideVariable/multiple'
import RefButton from "./Examples/Buttons/RefButton"
import AttachingToDomExample from './Examples/AttachingToDomExample'
import Chat from '../Chat'
import Alert from '../Alert'
import InteractiveExample from '../InteractiveExample'
import UsePreviousExample from './Examples/UsePreviousExample'

## What's useRef
`useRef` allows you to keep a mutable value within a component, similar to `useState` or instance variables on a class, without triggering re-renders.

For example, this component stores the number of clicks for a button:

```jsx
function RefButton () {
  const clicks = useRef(0)

  return (
    <button onClick={() => (clicks.current += 1)}>
      Clicks: {clicks.current}
    </button>
  )
}
```

This is how this component looks like (I added a re-render button so you can
actually test it out üòÑ):

<InteractiveExample>
  The example below is completely interactive, try clicking the "Clicks"
  button and then click on "Re-render".
  <OutsideVariableMultiple refs={1} displayType={false} displayTitles={false} />
</InteractiveExample>


As you can see, if you click the "Clicks" button it doesn't do anything. However, after click on "Re-render", it gets updated with the number of clicks we did previously.

### Why not just use a variable?
You might wonder why not just use a simple variable as the example below:

```jsx
let clicks = 0;

function OutsideVariableButton() {
  return (
    <button onClick={() => (clicks += 1)}>
      Clicks: {clicks}
    </button>
  )
}
```

And here's an interactive example for it:

<InteractiveExample>
  <OutsideVariableMultiple variable={1} />
</InteractiveExample>

The button works the same way that our previous example. However, the problem arises when you have multiple instances of the same component like the example below. Try clicking just one of the buttons and then click on re-render to see the result.

<InteractiveExample>
  <OutsideVariableMultiple variable={3} />
</InteractiveExample>

As you were able to see, the clicks are not isolated. In fact, all the examples
from this article uses the same button component, so if you click the button
from the first example and then click on "re-render" on the second example, the count it is gonna be
incremented! What a bug üêõ.

On the other hand, `useRef` values are completely isolated between components:

<InteractiveExample>
  <OutsideVariableMultiple refs={3} />
</InteractiveExample>

## Difference with¬†useState
`useState` triggers a re-render everytime it's updated and `useRef` doesn't. In the following example I added two buttons: one updates its count with `useRef` and the other one with `useState`. You'll notice that clicking on the button with `useRef` doesn't trigger a re-render and thus, the view isn't updated. It will be only noticeable when you click the button that uses `useState`.

<OutsideVariableMultiple refs={1} state={1} />

## Refs as a way to access underline DOM elements

To perform imperative actions on DOM nodes, React provides a way to get a
reference to them via refs. All you have to do is to assign a `ref` property to
a node with a ref object like this:

```jsx
function CustomInput() {
  const inputRef = useRef()

  return <input ref={inputRef} />
}
```

The way to get a DOM reference using refs works (informally üòÖ) is as follows:

<Chat
  messages={{
'Today': [
    { message:  'Hey React', side: 'right', time:'12:00' },
    { name: 'React', message: "Hey, what's up?", side: 'left', time: '12:00'},
    { message: "Could you give me a reference to this dom node?", side: 'right', time: '12:00' },
    { name:'React', message: "Sure, I assigned it to the 'current' property of your ref.", side: 'left', time:'12:00' },
    { message: "Cool, thanks!", side: 'right', time:'12:00' },
  ]}
}
 />

On the first render inputRef's value will be `{ current: null }` and in the
following renders will have its `current` property assigned to the specified DOM
node:

```jsx
// First render: { current: undefined }
// Second render: { current: <input /> }
// Third render: { current: <input /> }
/// ...and so on
console.log(inputRef)
```

However, if you only reference `inputRef` inside `useEffect` then it'll always
reference the DOM node so you don't need to worry about it being undefined.

Let's update our example to get an idea of how this works:

```jsx
function AttachingToDomExample() {
  const inputRef = useRef()

  console.log("Render inputRef value:", inputRef)

  useEffect(() => console.log("useEffect inputRef value:", inputRef))

  return <input ref={inputRef} />
}
```

Here's the console output when rendering this component:

| Render | Location | Value                       |
|:------:|:-------|:-----------------------------:|
| 1      |  Render    | { current: undefined }  |
|        |  useEffect | { current: <input /\> } |
| 2      |  Render    | { current: <input /\> } |
|        |  useEffect | { current: <input /\> } |
| 3      |  Render    | { current: <input /\> } |
|        |  useEffect | { current: <input /\> } |

As you can see, if you access the `inputRef` inside `useEffect` then you don't
need to worry about it being `undefined` because React will assign it
automatically for you.

# Real World Use Cases for Refs

Let's start with a simple real-world application for refs: `usePrevious`. This
hook stores the previous value for a given state variable.
[It is even referenced on React's docs](https://reactjs.org/docs/hooks-faq.html#how-to-get-the-previous-props-or-state) as a way to "get the previous props or state". Let's see it in
action first:

```jsx
function UsePreviousExample() {
  const [clicks, setClicks] = useState(0)
  const previousClicks = usePrevious(clicks)

  return (
    <div>
      <button onClick={() => setClicks(clicks + 1)}>
        Clicks: {clicks} - Before: {previousClicks}
      </button>
    </div>
  )
}
```

Here's the output so you can play with it:

<InteractiveExample>
  <UsePreviousExample />
</InteractiveExample>

You can notice that `previousClicks` stores the value for the previous render
for a given variable. Here's its implementation:

```jsx
function usePrevious(value) {
  const ref = useRef()
  useEffect(() => {
    ref.current = value
  })
  return ref.current
}
```


## TODO
- Lazy Initialization
- Describe that conceptually, you can think of refs as similar to instance variables in a class. Unless you're doing lazy initialization, avoid setting refs during rendering‚Ää-‚Ääthis can lead to surprising behavior. Instead, typically you want to modify refs in event handlers and effects.
- Callback refs
